# Introduction

- Before reading this note have this shadertoy open at the side for better understanding:
  https://www.shadertoy.com/view/4sSfzK

![[Pasted image 20240722211933.png#center | 600]]

**PBR** - Physically Based Rendering

- Matches lighting in physical world - more realistic
- Surface materials are based on physical parameters - advantageous as the materials will look correct regardless of lighting conditions - this is not true for non-PBR pipelines

Conditions for PBR lighting model
1. Be based on the microfacet surface model
2. Be energy conserving
3. Use a physically based BRDF

![[Pasted image 20240721104014.png#center]]

# Microfacet Model

The theory describes that any surface at a **microscopic scale** can be described by **tiny little perfectly reflective mirrors** called **microfacets**.

![[Pasted image 20240721104146.png#center]]

For specular reflections:
- Rough surface: light rays scatter along completely different directions -> widespread specular reflection
- Smooth surface: light rays reflect in more or less the same direction, giving smaller and sharper reflections

![[Pasted image 20240721104337.png#center]]

We approximate the surface's *microfacet roughness* using a *roughness parameter*. 
- Based on the microfacet roughness (which we take as the roughness of the surface) we can approximate the ratio of microfacets aligned to a vector `h`. Here we take `h` to be the halfway vector (halfway between light and view vector).

Halfway vector:
![[Pasted image 20240721105541.png#center]]

![[Pasted image 20240627202538.png#center | 300]]

Roughness parameter varies between 0.0 and 1.0. 
- More microfacets aligned to halfway vector -> sharper and stronger **specular reflection**

![[Pasted image 20240721114222.png#center]]

- We can see that higher *roughness values* display a much *larger specular reflection shape*, in contrast with the *smaller and sharper specular reflection shape* of smooth surfaces.

# Energy Conservation

The microfacet approximation employs a form of **energy conservation**: **outgoing light energy should never exceed the incoming light energy** (*excluding emissive surfaces*).

For energy conservation to hold, we need to make a clear distinction between diffuse and specular light. 
- The moment a light ray hits a surface, it gets split in both a refraction part and a reflection part.\
- The **reflection** part is light that directly gets reflected and doesn’t enter the surface; this is what we know as **specular lighting**.
- The **refraction** part is the remaining light that enters the surface and gets absorbed; this is what we know as **diffuse lighting**. Remember: the portions of the light components  which absorbed are not visible.

Remember: The reflected part, scattered components and re-emitted components of light are visible to the viewer. 

Light modeled as a beam keeps moving forward until it loses all of its energy, by collision with particles.
- The particles absorb some, or all, of the light’s energy at each collision which is converted into heat.

![[acc8b107-df6f-4638-9076-f6d7ffadfa821716758029564821198.png#center | 300]]

![[Pasted image 20240722001400.png#center]]

Light rays re-emerging out of the surface (after scattering) contribute to the surface’s observed (**diffuse**) color.

In physically based rendering however, we make the simplifying assumption that:
- all refracted light gets absorbed  and scattered at a very small area of impact, ignoring the effect of scattered light rays that would’ve exited the surface at a distance.

This is called **subsurface scattering techniques**.

## PBR Model

In PBR we assume that:\

1. The refracted portion of the light is mostly absorbed by the surface. A small portion of the light is scattered over a very small area of impact (scattered rays at a distance are ignored)
	- This scattered light is known as the **diffuse component**.

![[Pasted image 20240722210448.png#center]]
\
2. The **reflection** part is light that directly gets reflected and doesn’t enter the surface; this is what we know as **specular lighting**.

![[Pasted image 20240722210532.png#center]]

## Metallic surfaces

- all refracted light gets directly absorbed without scattering
- *metallic surfaces only leave reflected or specular light, no diffuse colors* (like a mirror showing only reflections)

No diffuse color for metallic surface, vs diffuse color for dielectric surface:

![[Pasted image 20240722211504.png#center  | 300]]

![[Pasted image 20240722211528.png#center | 300]]

## Calculations

$Total\,Light\,Energy = Reflected\,light\,energy+ Refracted\,light\,energy$

```c
float kS = calculateSpecularComponent(...); // reflection/specular fraction
float kD = 1.0 - kS; // refraction/diffuse fraction
```

Note: Blinn Phong model did not take into account energy conservation, as we could increase the specular component without needing to reduce the diffuse (refraction) component.

# Reflectance Equation

![[Pasted image 20240722102820.png]]

**Radiometry**: measurement of electromagnetic radiation, including visible light

## Radiance ($L$)

**Radiance** $L$: used to quantify the magnitude or strength of light coming from a single direction.

Radiance is a combination of multiple physical quantities as follows:
### 1. Radiant Flux ($Φ$)

It is the transmitted energy of a light source measured in **Watts**.

![[Pasted image 20240722115926.png#center | 500]]

The emitted energy of a light source can therefore be thought of as a function (sum) of all its different wavelengths.

Visible light: 390nm to 700nm

**Wavelength vs energy (Watts)**:

![[Pasted image 20240722105125.png#center | 500]]

We represent radiant flux as **RGB light color**, instead of function of different wavelengths. This causes loss of information, but is negligible for visual aspects.

### 2. Solid Angle ($ω$)

Tells us the size or area of a shape projected onto a unit sphere.
- The area of the projected shape onto this unit sphere is known as the solid angle; you can visualize the solid angle as *a direction with volume* (seen from the origin till the projection on the sphere)

![[Pasted image 20240722105525.png#center]]

### 3. Radiant Intensity ($I$)

Radiant intensity measures the amount of **radiant flux per solid angle**, or
the strength of a light source over a projected area onto the unit sphere.

![[Pasted image 20240722115759.png#center]]

![[Pasted image 20240722115808.png#center]]

where,
	I is the radiant intensity 
	Φ is radiant flux,
	ω is the solid angle

### Radiance Equation

Radiance is described as the **total observed energy** in an area $A$ over the solid angle $ω$ of a light of radiant intensity $Φ$ (*note $Φ$ here denotes the radiant intensity*):

![[Pasted image 20240722120251.png#center]]
<p class='img-caption'>Radiance Equation</p>

![[Pasted image 20240722120357.png#center | 200]]

Radiance is a radiometric measure of the *amount of light in an area*, **scaled** by the  incident (or incoming) angle $θ$ of the light to the surface’s normal by multiplying by $cos(θ)$

We use the radiance equation to calculate the radiance of a single light ray influencing a single point. So, we assume:
- area $A$ to be infinitely small
- solid angle $ω$ to be infinitely small

When implemented in our shader we get radiance of a single light light ray over a single **fragment**.

**Irradiance**: sum of all radiance over a point

## Back to Reflectance Equation

![[Pasted image 20240722102820.png#center | 500]]

$L_i$ - radiance of some point $p$ at incoming direction $w_i$
$w_i$ - infinitely small solid angle which can be though of as an incoming direction vector
$n·w_i$ - the dot product symbolizes the $cos(θ)$ which symbolizes the scaling of energy based on light's angle to the surface

$L_o$ measures the **reflected sum of the lights’ irradiance** (each point $p$ has an irradiance associated with it) **onto point $p$** as *viewed from $ω_o$*, which is the *outgoing direction to the viewer*.

## Code

The reflectance equation is based around irradiance, which is the sum of all incoming radiance we measure light of.
- Not just of a single incoming light direction, but of all incoming light directions within a *hemisphere $Ω$ centered around point $p$.*
- surface normal of hemisphere: $n$

Note: the reflectance equation gives irradiance **at a specific point $p$ (fragment)**. 

![[Pasted image 20240722143404.png#center]]

To calculate the *total of values inside* an area or (in the case of a hemisphere) a volume, we use an integral denoted in the reflectance equation as over all incoming
directions $dω$ i within the hemisphere $Ω$.\

**Riemann Sum:**
```c
int steps = 100;
float sum = 0.0f;
vec3 P = ...;
vec3 Wo = ...;
vec3 N = ...;

float dW = 1.0 / steps; // same is dW_i

for(int i = 0; i < steps; i+=dW) {
	vec3 Wi = getNextIncomingLightDir(i);
	sum += Fr(P, Wi, Wo) * L(P, Wi) * dot(N, Wi) * dW;
}
```

- The reflectance equation sums up the radiance of all incoming light directions ω i over the hemisphere Ω scaled by $f_r$ (**BRDF**) that hit point p and returns the sum of reflected light $L_o$ in the viewer’s direction. 
- The incoming radiance can come from light sources as we’re familiar with, or from an environment map measuring the radiance of every incoming direction

# BRDF (Cook-Torrance)

The BRDF, or **bidirectional reflective distribution function**, is a function that takes as input the 
- incoming (light) direction $ω_i$
- the outgoing (view) direction $ω_o$ 
- the surface normal $n$
- surface parameter $a$ that represents the **microsurface’s roughness**.

- It approximates how much each individual individual light ray $ω_i$ contributes to the final reflected light of an opaque surface, given its material properties

BRDF is based on microfacet theory and follows the law of energy conservation.

**Cook Torrance BRDF Equation**:

![[Pasted image 20240722151301.png#center]]

$k_d$ - ratio of incoming light energy that gets refracted
$k_s$ - ratio of incoming light energy that gets reflected

## Lambertian diffuse

![[Pasted image 20240722161041.png#center]]

c - surface color (from albedo / diffuse texture)

- **So the Lambertian Diffuse component gives a constant color**

## Cook Torrance Specular

![[Pasted image 20240722161332.png#center]]

$D$, $F$, $G$ - functions to approximate the surface's reflective properties
denominator - normalization factor

We’re going to pick the same functions used by Epic Game’s Unreal Engine 4 which are the Trowbridge-Reitz GGX for $D$, the Fresnel-Schlick approximation for $F$, and the Smith’s Schlick-GGX for $G$. (graphicrants.blogspot.nl/2013/08/specular-brdf-reference.html)

### 1. Normal Distribution Function (D)

Approximates the relative surface area of microfacets **exactly aligned** to the (halfway) vector $h$.

**Trowbridge-Reitz GGX**:

![[Pasted image 20240722170715.png#center]]

$h$ - halfway vector
$a$ - roughness parameter

As $a$ varies:

![[Pasted image 20240721114222.png#center]]

- When the roughness is low (thus the surface is smooth), a highly concentrated number of microfacets are aligned to halfway vectors over a **small radius**. (causing bright spot)
- Rough surface: microfacets are aligned in much more random directions. We find a **much larger number of halfway vectors $h$ somewhat aligned to the microfacets** (but *less concentrated*), giving us the more *grayish results*.

```c
// basically implement the above equation

float DistributionGGX(vec3 N, vec3 H, float a)
{
	float a2 = a*a;
	float NdotH = max(dot(N, H), 0.0);
	float NdotH2 = NdotH*NdotH;
	float nom = a2;
	float denom = (NdotH2 * (a2 - 1.0) + 1.0);
	denom = PI * denom * denom;
	
	return nom / denom;
}
```

### 2. Geometry Function

The geometry function statistically approximates the relative surface area where its micro surface details overshadow each other, causing light rays to be **occluded**.

![[Pasted image 20240722171739.png#center]]

Rougher surfaces have a higher probability of overshadowing microfacets.

**Schlick-GGX:**\

![[Pasted image 20240722173412.png#center]]

Here k is a remapping of α based on whether we’re using the geometry function  for either **direct lighting** or **IBL lighting**:

![[Pasted image 20240722173452.png#center]]

- Note that the value of α may differ based on how your engine translates roughness to $α$.

To effectively approximate the geometry we need to take account of both the view direction (**geometry obstruction**) and the light direction vector (**geometry shadowing**).

Using **Smith's Method** with Schlick-GGX as $G_{sub}$ :

![[Pasted image 20240722173744.png#center]]

With varying roughness $R$, above equation gives the result:

![[Pasted image 20240722173854.png#center | 500]]

The geometry function is a multiplier between $[0.0, 1.0]$ with `1.0` (or **white**) measuring *no microfacet shadowing*, and `0.0 `(or **black**) *complete microfacet shadowing*.

```c
float GeometrySchlickGGX(float NdotV, float k)
{
	float nom = NdotV;
	float denom = NdotV * (1.0 - k) + k;
	return nom / denom;
}

float GeometrySmith(vec3 N, vec3 V, vec3 L, float k)
{
	float NdotV = max(dot(N, V), 0.0);
	float NdotL = max(dot(N, L), 0.0);
	float ggx1 = GeometrySchlickGGX(NdotV, k);
	float ggx2 = GeometrySchlickGGX(NdotL, k);
	return ggx1 * ggx2;
}
```

### 3. Fresnel Equation

The Fresnel equation (pronounced as Freh-nel, (TIL) ) describes the ratio of light that gets reflected over the light that gets refracted. This varies with the angle at which we are looking at the surface.

All surfaces have a base reflectivity when seen perpendicular (straight) to the surface.
- As angle increases, the reflections become more apparent compared to the surface's base reflectivity.
- At perfect 90 degree view angle (viewing parallel to the surface), theoretically light is fully reflected. This phenomenon is known as **Fresnel**.

**Fresnel-Schlick approximation**:

![[Pasted image 20240722183053.png#center]]

- $F_0$ - **base reflectivity** of the surface, calculated using **indices of refraction** (**IOR**). 

At the grazing angles of the sphere (halfway view angle reaches 90 degrees), the Fresnel is stronger and hence more reflections.

![[Pasted image 20240722192700.png#center]]


- Fresnel Schlick approximation is defined for dielectric (non metallic) surfaces, not conductors. 


1. Pre compute the surface's response at normal incidence ($F_0$) at 0 degree angle (looking directly onto surface)
2. Interpolate this value based on the view angle by Fresnel Schlick approximation

The above method can be used for both metals and non metals.

![[Pasted image 20240722194650.png#center | 600]]

- For conductors, we see that the base reflectivity is tinted.

### Metallic Workflow

**metalness** parameter: describes whether a surface is either a metallic or a non-metallic surface.

> Theoretically, the metalness of a material is *binary*: it’s either a metal or it isn’t; it can’t be
> both. However, most render pipelines allow configuring the metalness of a surface **linearly**
> **between 0.0 and 1.0**. This is mostly because of the lack of material texture precision.
> For instance, a surface having small (non-metal) dust/sand-like particles/scratches over a
> metallic surface is difficult to render with binary metalness values.

## Code

```c
// F0 -> dielectric surface color
// surfaceColor.rgb -> metallic color (no reflections from diffuse component)
vec3 F0 = vec3(0.04);

F0 = mix(F0, surfaceColor.rgb, metalness); // assign final value to F0

// mix(x, y, a) = x*(1-a) + y*a
// metalness = 0.0 -> F0 (dielectric surface color)
// metalness = 1.0 -> surfaceColor.rgb (metal)
```

- A base reflectivity of 0.04 holds for *most dielectrics* and produces physically plausible results without having to author an additional surface parameter.
- Because metallic surfaces *absorb all refracted light* they have **no reflections from diffuse components** and we can directly use the *surface color texture as their base reflectivity*.

```c
vec3 fresnelSchlick(float cosTheta, vec3 F0)
{
	return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
}
```

# Cook-Torrance Reflectance Equation

Finally including all the components of Cook-Torrance BRDF, we get the final reflectance equation:

![[Pasted image 20240722202010.png#center]]

This equation now completely describes a physically based render model that is generally
recognized as what we commonly understand as physically based rendering, or PBR.

# Authoring PBR Materials

Each of the surface parameters we need for a PBR pipeline can be defined
or modeled by **textures**.

Below you’ll see a list of textures you’ll frequently find in a PBR pipeline together with its
visual output if supplied to a PBR renderer:

![[Pasted image 20240722202329.png#center]]

## 1. Albedo

- the albedo texture specifies for each texel the color of the surface, or the base reflectivity if that texel is metallic.
- This is largely similar to what we’ve been using before as a diffuse texture, *but all lighting information is extracted from the texture*.
- Diffuse textures often have slight shadows or darkened crevices inside the image which is something you don’t want in an albedo texture; it should **only contain the color** (or refracted absorption coefficients) of the surface.

## 2. Normal

- The normal map allows us to specify, per fragment, a unique normal to give the illusion that a surface is bumpier than its flat counterpart.

## 3. Metallic

- The metallic map specifies per texel whether a texel is either metallic or it isn’t. 
- Based on how the PBR engine is set up, artists can author metalness as either grayscale values or as binary black or white.

## 4. Roughness

- The roughness map specifies how rough a surface is on a per texel basis.
- The sampled roughness value of the roughness influences the statistical microfacet orientations of the surface.
- A rougher surface gets **wider and blurrier reflections**, while a smooth surface gets **focused and clear reflections**.
- Smoothness map is the inverse of the roughness map.
  - We convert a smoothness map to roughness map by: `roughness = (1.0 - smoothness)`

## 5. AO (Ambient Occlusion)

- specifies an extra shadowing factor of the surface and potentially surrounding geometry.

- Ex: If we have a brick surface for instance, 
	- the albedo texture should have no shadowing information inside the brick’s crevices.
	- The AO map however does specify these darkened edges as it’s more difficult for light to escape.

- The ambient occlusion map of a mesh/surface is either manually generated, or pre-calculated in 3D modeling programs.


## Summary

- Artists set and tweak these physically based input values on a per-texel basis and can base their texture values on the physical surface properties of real-world materials.
- This is one of the biggest advantages of a PBR render pipeline as these physical properties of a surface  remain the same, regardless of environment or lighting setup, making life easier for artists to get physically plausible results.
